<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Embedding to non-Euclidean spaces &mdash; umap 0.5 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery.css?v=61a4c737" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=1c40f30e"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
        <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="How to use AlignedUMAP" href="aligned_umap_basic_usage.html" />
    <link rel="prev" title="Document embedding using UMAP" href="document_embedding.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html">
            
              <img src="_static/logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.5
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide / Tutorial:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="basic_usage.html">How to Use UMAP</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameters.html">Basic UMAP Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="plotting.html">Plotting UMAP results</a></li>
<li class="toctree-l1"><a class="reference internal" href="reproducibility.html">UMAP Reproducibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="transform.html">Transforming New Data with UMAP</a></li>
<li class="toctree-l1"><a class="reference internal" href="inverse_transform.html">Inverse transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="parametric_umap.html">Parametric (neural network) Embedding</a></li>
<li class="toctree-l1"><a class="reference internal" href="sparse.html">UMAP on sparse data</a></li>
<li class="toctree-l1"><a class="reference internal" href="supervised.html">UMAP for Supervised Dimension Reduction and Metric Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="clustering.html">Using UMAP for Clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="outliers.html">Outlier detection using UMAP</a></li>
<li class="toctree-l1"><a class="reference internal" href="composing_models.html">Combining multiple UMAP models</a></li>
<li class="toctree-l1"><a class="reference internal" href="densmap_demo.html">Better Preserving Local Density with DensMAP</a></li>
<li class="toctree-l1"><a class="reference internal" href="mutual_nn_umap.html">Improving the Separation Between Similar Classes Using a Mutual k-NN Graph</a></li>
<li class="toctree-l1"><a class="reference internal" href="document_embedding.html">Document embedding using UMAP</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Embedding to non-Euclidean spaces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#plane-embeddings">Plane embeddings</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spherical-embeddings">Spherical embeddings</a></li>
<li class="toctree-l2"><a class="reference internal" href="#embedding-on-a-custom-metric-space">Embedding on a Custom Metric Space</a></li>
<li class="toctree-l2"><a class="reference internal" href="#a-practical-example">A Practical Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bonus-embedding-in-hyperbolic-space">Bonus: Embedding in Hyperbolic space</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="aligned_umap_basic_usage.html">How to use AlignedUMAP</a></li>
<li class="toctree-l1"><a class="reference internal" href="aligned_umap_politics_demo.html">AlignedUMAP for Time Varying Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="precomputed_k-nn.html">Precomputed k-nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmarking.html">Performance Comparison of Dimension Reduction Implementations</a></li>
<li class="toctree-l1"><a class="reference internal" href="release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Background on UMAP:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="how_umap_works.html">How UMAP Works</a></li>
<li class="toctree-l1"><a class="reference internal" href="performance.html">Performance Comparison of Dimension Reduction Implementations</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples of UMAP usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="interactive_viz.html">Interactive Visualizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="exploratory_analysis.html">Exploratory Analysis of Interesting Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="scientific_papers.html">Scientific Papers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api.html">UMAP API Guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">umap</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Embedding to non-Euclidean spaces</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/embedding_space.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="embedding-to-non-euclidean-spaces">
<h1>Embedding to non-Euclidean spaces<a class="headerlink" href="#embedding-to-non-euclidean-spaces" title="Permalink to this heading"></a></h1>
<p>By default UMAP embeds data into Euclidean space. For 2D visualization
that means that data is embedded into a 2D plane suitable for a
scatterplot. In practice, however, there aren’t really any major
constraints that prevent the algorithm from working with other more
interesting embedding spaces. In this tutorial we’ll look at how to get
UMAP to embed into other spaces, how to embed into your own custom
space, and why this sort of approach might be useful.</p>
<p>To start we’ll load the usual selection of libraries. In this case we
will not be using the <code class="docutils literal notranslate"><span class="pre">umap.plot</span></code> functionality, but working with
matplotlib directly since we’ll be generating some custom visualizations
for some of the more unique embedding spaces.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numba</span>
<span class="kn">import</span> <span class="nn">sklearn.datasets</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">import</span> <span class="nn">umap</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sns</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">rc</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;figure.figsize&#39;</span><span class="p">:(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)})</span>
</pre></div>
</div>
<p>As a test dataset we’ll use the PenDigits dataset from sklearn –
embedding into exotic spaces can be considerably more computationally
taxing, so a simple relatively small dataset is going to be useful.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">digits</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">load_digits</span><span class="p">()</span>
</pre></div>
</div>
<section id="plane-embeddings">
<h2>Plane embeddings<a class="headerlink" href="#plane-embeddings" title="Permalink to this heading"></a></h2>
<p>Plain old plane embeddings are simple enough – it is the default for
UMAP. Here we’ll run through the example again, just to ensure you are
familiar with how this works, and what the result of a UMAP embedding of
the PenDigits dataset looks like in the simple case of embedding in the
plane.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">plane_mapper</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">plane_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">plane_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Spectral&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/embedding_space_7_1.png" src="_images/embedding_space_7_1.png" />
</section>
<section id="spherical-embeddings">
<h2>Spherical embeddings<a class="headerlink" href="#spherical-embeddings" title="Permalink to this heading"></a></h2>
<p>What if we wanted to embed data onto a sphere rather than a plane? This
might make sense, for example, if we have reason to expect some sort of
periodic behaviour or other reasons to expect that no point can be
infinitely far from any other. To make UMAP embed onto a sphere we need
to make use of the <code class="docutils literal notranslate"><span class="pre">output_metric</span></code> parameter, which specifies what
metric to use for the <strong>output</strong> space. By default UMAP uses a Euclidean
<code class="docutils literal notranslate"><span class="pre">output_metric</span></code> (and even has a special faster code-path for this
case), but you can pass in other metrics. Among the metrics UMAP
supports is the Haversine metric, used for measuring distances on a
sphere, given in latitude and longitude (in radians). If we set the
<code class="docutils literal notranslate"><span class="pre">output_metric</span></code> to <code class="docutils literal notranslate"><span class="pre">&quot;haversine&quot;</span></code> then UMAP will use that to measure
distance in the embedding space.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sphere_mapper</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">output_metric</span><span class="o">=</span><span class="s1">&#39;haversine&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>The result is the pendigits data embedded with respect to haversine
distance on a sphere. The catch is that if we visualize this naively
then we will get nonsense.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">sphere_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sphere_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Spectral&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/embedding_space_11_1.png" src="_images/embedding_space_11_1.png" />
<p>What has gone astray is that under the embedding distance metric a point
at <span class="math notranslate nohighlight">\((0, \pi)\)</span> is distance zero from a point at <span class="math notranslate nohighlight">\((0, 3\pi)\)</span>
since that will wrap all the way around the equator. You’ll note that
the scales on the x and y axes of the above plot go well outside the
ranges <span class="math notranslate nohighlight">\((-\pi, \pi)\)</span> and <span class="math notranslate nohighlight">\((0, 2\pi)\)</span>, so this isn’t the
right representation of the data. We can, however, use straightforward
formulas to map this data onto a sphere embedded in 3d-space.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">sphere_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">sphere_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">sphere_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">sphere_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">sphere_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">z</span></code> give 3d coordinates for each embedding point
that lies on the surface of a sphere. We can visualize this using
matplotlib’s 3d plotting capabilities, and see that we have in fact
induced a quite reasonable embedding of the data onto the surface of a
sphere.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Spectral&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/embedding_space_15_1.png" src="_images/embedding_space_15_1.png" />
<p>If you prefer a 2d plot we can convert these into lat/long coordinates
in the appropriate ranges and get the equivalent of a map projection of
the sphere data.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Spectral&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/embedding_space_18_1.png" src="_images/embedding_space_18_1.png" />
</section>
<section id="embedding-on-a-custom-metric-space">
<h2>Embedding on a Custom Metric Space<a class="headerlink" href="#embedding-on-a-custom-metric-space" title="Permalink to this heading"></a></h2>
<p>What if you have some other custom notion of a metric space that you
would like to embed data into? In the same way that UMAP can support
custom written distance metrics for the input data (as long as they can
be compiled with numba), the <code class="docutils literal notranslate"><span class="pre">output_metric</span></code> parameter can accept
custom distance functions. One catch is that, to support gradient
descent optimization, the distance function needs to return both the
distance, and a vector for the gradient of the distance. This latter
point may require a little bit of calculus on the users part. A second
catch is that it is highly beneficial to parameterize the embedding
space in a way that has no coordinate constraints – otherwise the
gradient descent may step a point outside the embedding space, resulting
in bad things happening. This is why, for example, the sphere example
simply has points wrap around rather than constraining coordinates to be
in the appropriate ranges.</p>
<p>Let’s work through an example where we construct a distance metric and
gradient for a different sort of space: a
<a class="reference external" href="https://en.wikipedia.org/wiki/Torus">torus</a>. A torus is essentially
just the outer surface of a donut. We can parameterize the torus in
terms of x, y coordinates with the caveat that we can <a class="reference external" href="https://en.wikipedia.org/wiki/Torus#Flat_torus">“wrap around”
(similar to the
sphere)</a>. In such a
model distances are mostly just euclidean distances, we just have to
check for which is the shorter direction – across or wrapping around –
and ensure we account for the equivalence of wrapping around several
times. We can write a simple function to calculate that.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">torus_euclidean_grad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">torus_dimensions</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Standard euclidean distance.</span>

<span class="sd">    ..math::</span>
<span class="sd">        D(x, y) = \sqrt{\sum_i (x_i - y_i)^2}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">distance_sqr</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">torus_dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">distance_sqr</span> <span class="o">+=</span> <span class="n">a</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">distance_sqr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">torus_dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">torus_dimensions</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">a</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">distance_sqr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">distance</span><span class="p">,</span> <span class="n">g</span><span class="o">/</span><span class="p">(</span><span class="mf">1e-6</span> <span class="o">+</span> <span class="n">distance</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the gradient just derives from the standard euclidean
gradient, we just have to check the direction according to the way we’ve
wrapped around to compute the distance. We can now plug that function
directly in to the <code class="docutils literal notranslate"><span class="pre">output_metric</span></code> parameter and end up embedding data
on a torus.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">torus_mapper</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">output_metric</span><span class="o">=</span><span class="n">torus_euclidean_grad</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>As with the sphere case, a naive visualisation will look strange, due
the the wrapping around and equivalence of looping several times. But,
also just like the torus, we can construct a suitable visualization by
computing the 3d coordinates for the points using a little bit of
straightforward geometry (yes, I still had to look it up to check).</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">R</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># Size of the doughnut circle</span>
<span class="n">r</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Size of the doughnut cross-section</span>

<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">torus_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">torus_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">torus_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">torus_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">torus_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Now we can visualize the result using matplotlib and see that, indeed,
the data has been suitably embedded onto a torus.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Spectral&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_zlim3d</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="mi">35</span><span class="p">,</span> <span class="mi">70</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/embedding_space_26_0.png" src="_images/embedding_space_26_0.png" />
<p>And as with the torus we can do a little geometry and unwrap the torus
into a flat plane with the appropriate bounds.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">R</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Spectral&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/embedding_space_29_1.png" src="_images/embedding_space_29_1.png" />
</section>
<section id="a-practical-example">
<h2>A Practical Example<a class="headerlink" href="#a-practical-example" title="Permalink to this heading"></a></h2>
<p>While the examples given so far may have some use (because some data
does have suitable periodic or looping structures that we expect will be
better represented in a sphere or a torus), most data doesn’t really
fall in the realm of something that a user can, apriori, expect to lie
on an exotic manifold. Are there more practical uses for the ability to
embed in other spaces? It turns out that there are. One interesting
example to consider is the space formed by 2d-Gaussian distributions. We
can measure the distance between two Gaussians (parameterized by a 2d
vector for the mean, and 2x2 matrix giving the covariance) by the
negative log of the inner product between the PDFs (since this has a
nice closed form solution, and is reasonably computable). That gives us
a metric space to embed into where samples are represented not as points
in 2d, but as Gaussian distributions in 2d, encoding some uncertainty in
how each sample in the high dimensional space is to be embedded.</p>
<p>Of course we still have the issues of parameterizations that are
suitable for SGD – requiring that the covariance matrix be symmetric
and positive definite is challenging. Instead we can parameterize the
covariance in terms of a width, height and angle, and recover the
covariance matrix from these if required. That gives us a total of 5
components to embed into (two for the mean, 3 for parameters describing
the covariance). We can simply do this since the appropriate metric is
defined already. Note that we have to specifically pass
<code class="docutils literal notranslate"><span class="pre">n_components=5</span></code> since we need to explicitly embed into a 5
dimensional space to support all the covariance parameters associated to
2d Gaussians.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">gaussian_mapper</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">output_metric</span><span class="o">=</span><span class="s1">&#39;gaussian_energy&#39;</span><span class="p">,</span>
                            <span class="n">n_components</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                            <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>Since we have embedded the data into a 5 dimensional space visualization
is not as trivial as it was earlier. We can get a start on visualizing
the results by looking at just the means, which are the 2d locations of
the modes of the Gaussians. A traditional scatter plot will suffice for
this.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">gaussian_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gaussian_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Spectral&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/embedding_space_33_1.png" src="_images/embedding_space_33_1.png" />
<p>We see that we have gotten a result similar to a standard embedding into
euclidean space, but with less clear clustering, and more points between
clusters. To get a clearer idea of what is going on it will be necessary
to devise a means to display some of the extra information contained in
the extra 3 dimensions providing covariance data. To do this it will be
helpful to be able to draw ellipses corresponding to super-level sets of
the PDF of the 2d Gaussian. We can start on this by writing a simple
function to draw ellipses on a plot accoriding to a position, a width, a
height, and an angle (since this is the format the embedding computed
the data).</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Ellipse</span>

<span class="k">def</span> <span class="nf">draw_simple_ellipse</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span>
                        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">from_size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">to_size</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">n_ellipses</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span> <span class="ow">or</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="p">(</span><span class="n">angle</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span>
    <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">width</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
    <span class="c1"># Draw the Ellipse</span>
    <span class="k">for</span> <span class="n">nsig</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">from_size</span><span class="p">,</span> <span class="n">to_size</span><span class="p">,</span> <span class="n">n_ellipses</span><span class="p">):</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">Ellipse</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">nsig</span> <span class="o">*</span> <span class="n">width</span><span class="p">,</span> <span class="n">nsig</span> <span class="o">*</span> <span class="n">height</span><span class="p">,</span>
                             <span class="n">angle</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
</pre></div>
</div>
<p>Now we can plot the data by providing a scatterplot of the centers (as
before), but overlaying that over a super-level-set ellipses of the
associated Gaussians. The obvious catch is that this will induce a lot
of over-plotting, but it will at least provide a way to start
understanding the embedding we have produced.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;Spectral&#39;</span><span class="p">)(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">gaussian_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">gaussian_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">draw_simple_ellipse</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">gaussian_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                        <span class="n">gaussian_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
                        <span class="n">gaussian_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
                        <span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
                        <span class="n">from_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">to_size</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">gaussian_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
           <span class="n">gaussian_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
           <span class="n">c</span><span class="o">=</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Spectral&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/embedding_space_37_1.png" src="_images/embedding_space_37_1.png" />
<p>Now we can see that the covariance structure for the points can vary
greatly, both in absolute size, and in shape. We note that many of the
points falling between clusters have much larger variances, in a sense
representing the greater uncertainty of the location of the embedding.
It is also worth noting that the shape of the ellipses can vary
significantly – there are several very stretched ellipses, quite
distinct from many of the very round ellipses; in a sense this
represents where the uncertainty falls more along a single line for
example.</p>
<p>While this plot highlights some of the covariance structure in the
outlying points, in practice the overplotting here obscures a lot of the
more interesting structure in the clusters themselves. We can try to see
this structure better by plotting only a single ellipse per point and
using a lower alpha channel value for the ellipses, making them more
translucent.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">gaussian_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">gaussian_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">draw_simple_ellipse</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">gaussian_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                        <span class="n">gaussian_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
                        <span class="n">gaussian_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
                        <span class="n">ax</span><span class="p">,</span> <span class="n">n_ellipses</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
                        <span class="n">from_size</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">to_size</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">gaussian_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
           <span class="n">gaussian_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
           <span class="n">c</span><span class="o">=</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Spectral&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/embedding_space_39_1.png" src="_images/embedding_space_39_1.png" />
<p>This lets us see the variation of density of clusters with respect to
the covariance structure – some clusters have consistently very tight
covariance, while others are more spread out (and hence have, in a sense,
greater associated uncertainty. Of course we still have a degree of
overplotting even here, and it will become increasingly difficult to
tune alpha channels to make things visible. Instead what we would want
is an actual density plot, showing the the density of the sum over all
of these Gaussians.</p>
<p>To do this we’ll need to define some functions, whose execution will be
accelerated using numba: the evaluation of the density of a 2d Gaussian
at a given point; an evaluation of the density of a given point summing
over a set of several Gaussians; and a function to generate the density
for each point in some grid (summing only over nearby Gaussians to make
this naive approach more computable).</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KDTree</span>

<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">eval_gaussian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">cov</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)):</span>
    <span class="n">det</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">cov</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">cov</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">det</span> <span class="o">&gt;</span> <span class="mf">1e-16</span><span class="p">:</span>
        <span class="n">cov_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cov</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="o">-</span><span class="n">cov</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]])</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">det</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">pos</span>
        <span class="n">m_dist</span> <span class="o">=</span> <span class="n">cov_inv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> \
            <span class="p">(</span><span class="n">cov_inv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">cov_inv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">diff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
            <span class="n">cov_inv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">diff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">m_dist</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">det</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>

<span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">eval_density_at_point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">embedding</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)]])</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="n">U</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">embedding</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span> <span class="o">@</span> <span class="n">U</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">eval_gaussian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="n">cov</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">create_density_plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">embedding</span><span class="p">):</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">embedding</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">nearby_points</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">tree</span><span class="o">.</span><span class="n">query_radius</span><span class="p">([[</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]]],</span> <span class="n">r</span><span class="o">=</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">eval_density_at_point</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]]),</span> <span class="n">nearby_points</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Z</span> <span class="o">/</span> <span class="n">Z</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
</pre></div>
</div>
<p>Now we simply need an appropriate grid of points. We can use the plot
bounds seen above, and a grid size selected for the sake of
computability. The numpy <code class="docutils literal notranslate"><span class="pre">meshgrid</span></code> function can supply the actual
grid.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">300</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">300</span><span class="p">))</span>
</pre></div>
</div>
<p>Now we can use the function defined above to compute the density at each
point in the grid, given the Gaussians produced by the embedding.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Z</span> <span class="o">=</span> <span class="n">create_density_plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">gaussian_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we can view the result as a density plot using <code class="docutils literal notranslate"><span class="pre">imshow</span></code>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Reds&#39;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">0.0005</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
</pre></div>
</div>
<img alt="_images/embedding_space_47_1.png" src="_images/embedding_space_47_1.png" />
<p>Here we see the finer structure within the various clusters, including
some of the interesting linear structures, demonstrating that this
Gaussian uncertainty based embedding has captured quite detailed and
useful information about the inter-relationships among the PenDigits
dataset.</p>
</section>
<section id="bonus-embedding-in-hyperbolic-space">
<h2>Bonus: Embedding in Hyperbolic space<a class="headerlink" href="#bonus-embedding-in-hyperbolic-space" title="Permalink to this heading"></a></h2>
<p>As a bonus example let’s look at embedding data into hyperbolic space.
The most popular model for this for visualization is <a class="reference external" href="https://en.wikipedia.org/wiki/Poincar%C3%A9_disk_model">Poincare’s disk
model</a>. An
example of a regular tiling of hyperbolic space in Poincare’s disk model
is shown below; you may note it is similar to famous images by M.C.
Escher.</p>
<a class="reference internal image-reference" href="_images/Hyperbolic_tiling.png"><img alt="_images/Hyperbolic_tiling.png" src="_images/Hyperbolic_tiling.png" style="width: 400px; height: 400px;" /></a>
<p>Ideally we would be able to embed directly into this Poincare disk
model, but in practice this proves to be very difficult. The issue is
that the disk has a “line at infinity” in a circle of radius one
bounding the disk. Outside of that circle things are not well defined.
As you may recall from the discussion of embedding onto spheres and
toruses it is best if we can have a parameterisation of the embedding
space that it is hard to move out of. The Poincare disk model is almost
the opposite of this – as soon as we move outside the unit circle we
have moved off the manifold and further updates will be badly defined.
We therefore instead need a different parameterisation of hyperbolic
space that is less constrained. One option is the Poincare half-plane
model, but this, again, has a boundary that it is easy to move beyond.
The simplest option is the <a class="reference external" href="https://en.wikipedia.org/wiki/Hyperboloid_model">hyperboloid
model</a>. Under this
model we can simply move in x and y coordinates, and solve for the
corresponding z coordinate when we need to compute distances. This model
has been implemented under the distance metric <code class="docutils literal notranslate"><span class="pre">&quot;hyperboloid&quot;</span></code> so we
can simply use it out-of-the-box.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">hyperbolic_mapper</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">output_metric</span><span class="o">=</span><span class="s1">&#39;hyperboloid&#39;</span><span class="p">,</span>
                              <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>A straightforward visualization option is to simply view the x and y
coordinates we have arrived at:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">hyperbolic_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">hyperbolic_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">c</span><span class="o">=</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Spectral&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/embedding_space_52_1.png" src="_images/embedding_space_52_1.png" />
<p>We can also solve for the z coordinate and view the data lying on a
hyperboloid in 3d space.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">hyperbolic_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">hyperbolic_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">hyperbolic_mapper</span><span class="o">.</span><span class="n">embedding_</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Spectral&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="mi">35</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/embedding_space_55_0.png" src="_images/embedding_space_55_0.png" />
<p>But we can do more – since we have embedded the data successfully in
hyperbolic space we can map the data into the Poincare disk model. This
is, in fact, a straightforward computation.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">disk_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>
<span class="n">disk_y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we can visualize the data in a Poincare disk model embedding as we
first wanted. For this we simply generate a scatterplot of the data, and
then draw in the bounding circle of the line at infinity.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">disk_x</span><span class="p">,</span> <span class="n">disk_y</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Spectral&#39;</span><span class="p">)</span>
<span class="n">boundary</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">);</span>
</pre></div>
</div>
<img alt="_images/embedding_space_59_0.png" src="_images/embedding_space_59_0.png" />
<p>Hopefully this has provided a useful example of how to go about
embedding into non-euclidean spaces. This last example ideally
highlights the limitations of this approach (we really need a suitable
parameterisation), and some potential approaches to get around this: we
can use an alternative parameterisation for the embedding, and then
transform the data into the desired representation.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="document_embedding.html" class="btn btn-neutral float-left" title="Document embedding using UMAP" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="aligned_umap_basic_usage.html" class="btn btn-neutral float-right" title="How to use AlignedUMAP" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018, Leland McInnes.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>