<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Combining multiple UMAP models &mdash; umap 0.5 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery.css?v=61a4c737" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=1c40f30e"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
        <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Better Preserving Local Density with DensMAP" href="densmap_demo.html" />
    <link rel="prev" title="Outlier detection using UMAP" href="outliers.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html">
            
              <img src="_static/logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.5
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide / Tutorial:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="basic_usage.html">How to Use UMAP</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameters.html">Basic UMAP Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="plotting.html">Plotting UMAP results</a></li>
<li class="toctree-l1"><a class="reference internal" href="reproducibility.html">UMAP Reproducibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="transform.html">Transforming New Data with UMAP</a></li>
<li class="toctree-l1"><a class="reference internal" href="inverse_transform.html">Inverse transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="parametric_umap.html">Parametric (neural network) Embedding</a></li>
<li class="toctree-l1"><a class="reference internal" href="sparse.html">UMAP on sparse data</a></li>
<li class="toctree-l1"><a class="reference internal" href="supervised.html">UMAP for Supervised Dimension Reduction and Metric Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="clustering.html">Using UMAP for Clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="outliers.html">Outlier detection using UMAP</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Combining multiple UMAP models</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#mnist-digits-example">MNIST digits example</a></li>
<li class="toctree-l2"><a class="reference internal" href="#diamonds-dataset-example">Diamonds dataset example</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="densmap_demo.html">Better Preserving Local Density with DensMAP</a></li>
<li class="toctree-l1"><a class="reference internal" href="mutual_nn_umap.html">Improving the Separation Between Similar Classes Using a Mutual k-NN Graph</a></li>
<li class="toctree-l1"><a class="reference internal" href="document_embedding.html">Document embedding using UMAP</a></li>
<li class="toctree-l1"><a class="reference internal" href="embedding_space.html">Embedding to non-Euclidean spaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="aligned_umap_basic_usage.html">How to use AlignedUMAP</a></li>
<li class="toctree-l1"><a class="reference internal" href="aligned_umap_politics_demo.html">AlignedUMAP for Time Varying Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="precomputed_k-nn.html">Precomputed k-nn</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmarking.html">Performance Comparison of Dimension Reduction Implementations</a></li>
<li class="toctree-l1"><a class="reference internal" href="release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Background on UMAP:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="how_umap_works.html">How UMAP Works</a></li>
<li class="toctree-l1"><a class="reference internal" href="performance.html">Performance Comparison of Dimension Reduction Implementations</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples of UMAP usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="interactive_viz.html">Interactive Visualizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="exploratory_analysis.html">Exploratory Analysis of Interesting Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="scientific_papers.html">Scientific Papers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api.html">UMAP API Guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">umap</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Combining multiple UMAP models</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/composing_models.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="combining-multiple-umap-models">
<h1>Combining multiple UMAP models<a class="headerlink" href="#combining-multiple-umap-models" title="Permalink to this heading"></a></h1>
<p>It is possible to combine together multiple UMAP models, assuming that
they are operating on the same underlying data. To get an idea of how
this works recall that UMAP uses an intermediate fuzzy topological
representation (see <a class="reference internal" href="how_umap_works.html#how-umap-works"><span class="std std-ref">How UMAP Works</span></a>). Given different views of the
same underlying data this will generate different fuzzy topological
representations. We can apply intersections or unions to these
representations to get a new composite fuzzy topological representation
which we can then embed into low dimensional space in the standard UMAP
way. The key is that, to be able to sensibly intersect or union these
representations, there must be one-to-one correspondences between the
data samples from the two different views.</p>
<p>To get an idea of how this might work it is useful to see it in
practice. Let’s load some libraries and get started.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sklearn.datasets</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">RobustScaler</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">umap</span>
<span class="kn">import</span> <span class="nn">umap.plot</span>
</pre></div>
</div>
<section id="mnist-digits-example">
<h2>MNIST digits example<a class="headerlink" href="#mnist-digits-example" title="Permalink to this heading"></a></h2>
<p>To begin with let’s use a relatively familiar dataset – the MNIST digits
dataset that we’ve used in other sections of this tutorial. The data is
(grayscale) 28x28 pixel images of handwritten digits (0 through 9); in
total there are 70,000 such images, and each image is unrolled into a
784 element vector.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">mnist</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">fetch_openml</span><span class="p">(</span><span class="s2">&quot;mnist_784&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>To ensure we have an idea of what this dataset looks like through the
lens of UMAP we can run UMAP on the full dataset.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">mapper</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">mnist</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">umap</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">points</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">mnist</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/composing_models_6_1.png" src="_images/composing_models_6_1.png" />
<p>To make the problem more interesting let’s carve the dataset in two – not
into two sets of 35,000 samples, but instead carve each image in half.
That is, we’ll end up with 70,000 samples each of which is the top half
of the image of the handwritten digit, and another 70,000 samples each
of which is the bottom half of the image of the handwritten digit.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">top</span> <span class="o">=</span> <span class="n">mnist</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">28</span> <span class="o">*</span> <span class="mi">14</span><span class="p">]</span>
<span class="n">bottom</span> <span class="o">=</span> <span class="n">mnist</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">28</span> <span class="o">*</span> <span class="mi">14</span><span class="p">:]</span>
</pre></div>
</div>
<p>This is a little artificial, but it provides us with an example dataset
where we have two distinct views of the data which we can still well
understand. In practice this situation would be more likely to arise
when there are two different data collection processes sampling from the
same underlying population. In our case we could simply glue the data
back together (hstack the numpy arrays for example), but potentially
this isn’t feasible as the different data views may have different
scales or modalities. So, despite the fact that we could glue things
back together in this case, we will proceed as if we can’t – as may be
the case for many real world problems.</p>
<p>Let’s first look at what UMAP does individually on each dataset. We’ll
start with the top halves of the digits:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">top_mapper</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">umap</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">points</span><span class="p">(</span><span class="n">top_mapper</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">mnist</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/composing_models_11_1.png" src="_images/composing_models_11_1.png" />
<p>While UMAP still manages to mostly separate the different digit classes
we can see the results are quite different from UMAP on the full
standard MNIST dataset. The twos and threes are blurred together (as we
would expect given that we don’t have the bottom half of the image wich
would let us tell them apart); The twos and threes are also in a large
grouping that pulls together all of the eights, sevens and nines (again,
what we would expect given only the top half of the digit), while the
fives and sixes are somewhat distinct, but clearly are similar to each
other. It is only the ones, fours and zeros that are very clearly
discernible.</p>
<p>Now let’s see what sorts of results we get with the bottom halves of the
digits:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">bot_mapper</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">bottom</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">umap</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">points</span><span class="p">(</span><span class="n">bot_mapper</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">mnist</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/composing_models_14_1.png" src="_images/composing_models_14_1.png" />
<p>This is clearly a very different view of the data. Now it is the fours
and nines that blur together (presumably many of the nines are drawn
with straight rather than curved stems), with sevens nearby. The twos
and the threes are very distinct from each other, but the threes and the
fives are combined (as one might expect given that the bottom halves
<em>should</em> look similar). Zeros and sixes are distinct, but close to each
other. Ones, eights and twos are the most distinctive digits in this
view.</p>
<p>So, assuming we can’t just glue the raw data together and stick a
reasonable metric on it, what can we do? We can perform intersections or
unions on the fuzzy topological representations. There is also some work
to be done re-asserting UMAP’s theoretical assumptions (local
connectivity, approximately uniform distributions). Fortunately UMAP
makes this relatively easy as long as you have a copy of fitted UMAP
models on hand (which we do in this case). To intersect two models
simply use the <code class="docutils literal notranslate"><span class="pre">*</span></code> operator; to union them use the <code class="docutils literal notranslate"><span class="pre">+</span></code> operator.
Note that this will actually take some time since we need to compute the
2D embedding of the combined model.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">intersection_mapper</span> <span class="o">=</span> <span class="n">top_mapper</span> <span class="o">*</span> <span class="n">bot_mapper</span>
<span class="n">union_mapper</span> <span class="o">=</span> <span class="n">top_mapper</span> <span class="o">+</span> <span class="n">bot_mapper</span>
</pre></div>
</div>
<p>With that complete we can visualize the results. First let’s look at the
intersection:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">umap</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">points</span><span class="p">(</span><span class="n">intersection_mapper</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">mnist</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/composing_models_18_1.png" src="_images/composing_models_18_1.png" />
<p>As you can see, while this isn’t as good as a UMAP plot for the full
MNIST dataset it has recovered the individual digits quite well. The
worst of the remaining overlap is between the threes and fives in the
center, which is it still struggling to fully distinguish. But note,
also, that we have recovered more of the overall structure than either
of the two different individual views, with the layout of different
digit classes more closely resembling that of the UMAP run on the full
dataset.</p>
<p>Now let’s look at the union.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">umap</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">points</span><span class="p">(</span><span class="n">union_mapper</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">mnist</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/composing_models_20_1.png" src="_images/composing_models_20_1.png" />
<p>Given that UMAP is agnostic to rotation or reflection of the final
layout, this is essentially the same result as the intersection since it
is almost the reflection of it in the y-axis. This sort of result
(intersection and union being similar) is not always the case (in fact
it is not that common), but since the underlying structure of the digits
dataset is so clear we find that either way of piecing it together from
the two half datasets manage to find the same core underlying structure.</p>
<p>If you are willing to try something a little more experimental there is
also a third option using the <code class="docutils literal notranslate"><span class="pre">-</span></code> operator which effectively
intersects with the fuzzy set complement (and is thus not commutative,
just as <code class="docutils literal notranslate"><span class="pre">-</span></code> implies). The goal here is to try to provide a sense of
what the data looks like when we contrast it against a second view.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">contrast_mapper</span> <span class="o">=</span> <span class="n">top_mapper</span> <span class="o">-</span> <span class="n">bot_mapper</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">umap</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">points</span><span class="p">(</span><span class="n">contrast_mapper</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">mnist</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/composing_models_23_1.png" src="_images/composing_models_23_1.png" />
<p>In this case the result is not overly dissimilar from the embedding of
just the top half, so the contrast has perhaps not shown is as much as
we might have hoped.</p>
</section>
<section id="diamonds-dataset-example">
<h2>Diamonds dataset example<a class="headerlink" href="#diamonds-dataset-example" title="Permalink to this heading"></a></h2>
<p>Now let’s try the same approach on a different dataset where the option
of just running UMAP on the full dataset is not available. For this
we’ll use the diamonds dataset. In this dataset each row represents a
different diamond and provides details on the weight (carat), cut,
color, clarity, size (depth, table, x, y, z) and price of the given
diamond. How these different factors interplay is somewhat complicated.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">diamonds</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">load_dataset</span><span class="p">(</span><span class="s1">&#39;diamonds&#39;</span><span class="p">)</span>
<span class="n">diamonds</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>carat</th>
      <th>cut</th>
      <th>color</th>
      <th>clarity</th>
      <th>depth</th>
      <th>table</th>
      <th>price</th>
      <th>x</th>
      <th>y</th>
      <th>z</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.23</td>
      <td>Ideal</td>
      <td>E</td>
      <td>SI2</td>
      <td>61.5</td>
      <td>55.0</td>
      <td>326</td>
      <td>3.95</td>
      <td>3.98</td>
      <td>2.43</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.21</td>
      <td>Premium</td>
      <td>E</td>
      <td>SI1</td>
      <td>59.8</td>
      <td>61.0</td>
      <td>326</td>
      <td>3.89</td>
      <td>3.84</td>
      <td>2.31</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.23</td>
      <td>Good</td>
      <td>E</td>
      <td>VS1</td>
      <td>56.9</td>
      <td>65.0</td>
      <td>327</td>
      <td>4.05</td>
      <td>4.07</td>
      <td>2.31</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.29</td>
      <td>Premium</td>
      <td>I</td>
      <td>VS2</td>
      <td>62.4</td>
      <td>58.0</td>
      <td>334</td>
      <td>4.20</td>
      <td>4.23</td>
      <td>2.63</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.31</td>
      <td>Good</td>
      <td>J</td>
      <td>SI2</td>
      <td>63.3</td>
      <td>58.0</td>
      <td>335</td>
      <td>4.34</td>
      <td>4.35</td>
      <td>2.75</td>
    </tr>
  </tbody>
</table>
</div><p>For our purposes let’s take “price” as a “target” variable (as is often
the case when the dataset is used in machine learning contexts). What we
would like to do is provide a UMAP embedding of the data using the
remaining features. This is tricky since we can’t exactly use a
euclidean metric over the whole thing. What we can do, however, is split
the data into two distinct types: the purely numeric features relating
to size and weight, and the categorical features of color, cut and
clarity. Let’s pull each of those feature sets out so we can work with
them independently.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">numeric</span> <span class="o">=</span> <span class="n">diamonds</span><span class="p">[[</span><span class="s2">&quot;carat&quot;</span><span class="p">,</span> <span class="s2">&quot;table&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">ordinal</span> <span class="o">=</span> <span class="n">diamonds</span><span class="p">[[</span><span class="s2">&quot;cut&quot;</span><span class="p">,</span> <span class="s2">&quot;color&quot;</span><span class="p">,</span> <span class="s2">&quot;clarity&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
<p>Now we have a new problem: the numeric features are not at all on the
same scales, so any sort of standard distance metric across them will be
dominated by those features with the largest ranges. We can correct for
that by performing feature scaling. To do that we’ll make use of
sklearn’s <code class="docutils literal notranslate"><span class="pre">RobustScaler</span></code> which uses robust statistics (such as the
median and interquartile range) to center and rescale the data feature
by feature. If we look at the results on the first five rows we see that
the different features are all now reasonably comparable, and it is
reasonable to apply something like euclidean distance across them.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">scaled_numeric</span> <span class="o">=</span> <span class="n">RobustScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">numeric</span><span class="p">)</span>
<span class="n">scaled_numeric</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.734375</span>  <span class="p">,</span> <span class="o">-</span><span class="mf">0.66666667</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.95628415</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.95054945</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.97345133</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">0.765625</span>  <span class="p">,</span>  <span class="mf">1.33333333</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.98907104</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.02747253</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.07964602</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">0.734375</span>  <span class="p">,</span>  <span class="mf">2.66666667</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.90163934</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.9010989</span> <span class="p">,</span> <span class="o">-</span><span class="mf">1.07964602</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">0.640625</span>  <span class="p">,</span>  <span class="mf">0.33333333</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.81967213</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.81318681</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.79646018</span><span class="p">],</span>
       <span class="p">[</span><span class="o">-</span><span class="mf">0.609375</span>  <span class="p">,</span>  <span class="mf">0.33333333</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.7431694</span> <span class="p">,</span> <span class="o">-</span><span class="mf">0.74725275</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.69026549</span><span class="p">]])</span>
</pre></div>
</div>
<p>What is the best way to handle the categorical features? If they are
purely categorical it would make sense to one-hot encode the categories
and use “dice” distance between them. A downside of that is that, with
so few categories, it is a very coarse metric which will fail to provide
much differentiation. For the diamonds dataset, however, the categories
come with a strict order: Ideal cut is better than Premium cut, which is
better than Very Good cut and so on. Color grades work similarly, and
there is a distinct grading scheme for clarity as well. We can use an
ordinal encoding on these categories. Now, while the <em>ranges</em> of values
may vary, the differences between them are all comparable – a difference
of 1 for each grade level. That means we don’t need to rescale this data
after the ordinal coding.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ordinal</span><span class="p">[</span><span class="s2">&quot;cut&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ordinal</span><span class="o">.</span><span class="n">cut</span><span class="o">.</span><span class="n">map</span><span class="p">({</span><span class="s2">&quot;Fair&quot;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Good&quot;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Very Good&quot;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Premium&quot;</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;Ideal&quot;</span><span class="p">:</span><span class="mi">4</span><span class="p">})</span>
<span class="n">ordinal</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ordinal</span><span class="o">.</span><span class="n">color</span><span class="o">.</span><span class="n">map</span><span class="p">({</span><span class="s2">&quot;D&quot;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;I&quot;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;J&quot;</span><span class="p">:</span><span class="mi">6</span><span class="p">})</span>
<span class="n">ordinal</span><span class="p">[</span><span class="s2">&quot;clarity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ordinal</span><span class="o">.</span><span class="n">clarity</span><span class="o">.</span><span class="n">map</span><span class="p">({</span><span class="s2">&quot;I1&quot;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;SI2&quot;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;SI1&quot;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;VS2&quot;</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;VS1&quot;</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;VVS2&quot;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;VVS1&quot;</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span> <span class="s2">&quot;IF&quot;</span><span class="p">:</span><span class="mi">7</span><span class="p">})</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ordinal</span>
</pre></div>
</div>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>cut</th>
      <th>color</th>
      <th>clarity</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>4</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>3</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>1</td>
      <td>4</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>5</td>
      <td>3</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1</td>
      <td>6</td>
      <td>1</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>53935</th>
      <td>4</td>
      <td>0</td>
      <td>2</td>
    </tr>
    <tr>
      <th>53936</th>
      <td>1</td>
      <td>0</td>
      <td>2</td>
    </tr>
    <tr>
      <th>53937</th>
      <td>2</td>
      <td>0</td>
      <td>2</td>
    </tr>
    <tr>
      <th>53938</th>
      <td>3</td>
      <td>4</td>
      <td>1</td>
    </tr>
    <tr>
      <th>53939</th>
      <td>4</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<p>53940 rows × 3 columns</p>
</div><p>As noted we can use euclidean as a sensible distance on the rescaled
numeric data. On the other hand since the different ordinal categories
are entirelty independent of each other, and we have a strict ordinal
codin, the socalled “manhattan” metric makes more sense here – it is
simply the sum of the absolute differences in each category. As before
we can now train UMAP models on each dataset – this time, however, since
the datasets are different we need different metrics and even different
values of <code class="docutils literal notranslate"><span class="pre">n_neighbors</span></code>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">numeric_mapper</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">scaled_numeric</span><span class="p">)</span>
<span class="n">ordinal_mapper</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="s2">&quot;manhattan&quot;</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">ordinal</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
</pre></div>
</div>
<p>We can look at the results of each of these independent views of the
dataset reduced to 2D using UMAP. Let’s first look at the numeric data
on size and weight of the diamonds. We can colour by the price to get
some idea of how the dataset fits together.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">umap</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">points</span><span class="p">(</span><span class="n">numeric_mapper</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">diamonds</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;viridis&quot;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/composing_models_36_1.png" src="_images/composing_models_36_1.png" />
<p>We see that while the data generally correlates somewhat with the price
of the diamonds there are distinctly different threads in the data,
presumably corresponding to different styles of cut, and how that
results in different sizing of diamonds in the various dimensions,
depending on the weight.</p>
<p>In contrast we ca look at the ordinal data. In this case we’ll colour it
by the different categories as well as by price.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">12</span><span class="p">))</span>
<span class="n">umap</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">points</span><span class="p">(</span><span class="n">ordinal_mapper</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">diamonds</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">umap</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">points</span><span class="p">(</span><span class="n">ordinal_mapper</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">diamonds</span><span class="p">[</span><span class="s2">&quot;clarity&quot;</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">umap</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">points</span><span class="p">(</span><span class="n">ordinal_mapper</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">diamonds</span><span class="p">[</span><span class="s2">&quot;cut&quot;</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">umap</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">points</span><span class="p">(</span><span class="n">ordinal_mapper</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">diamonds</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;viridis&quot;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<img alt="_images/composing_models_38_1.png" src="_images/composing_models_38_1.png" />
<p>As you can see this is a markedly different result! The ordinal data has
a relatively coarse metric, since the different categories can only take
on a small range of discrete values. This means that, with respect to
the trio of color, cut, and clarity, diamonds are largely either almost
identical, or quite distinct. The result is very tight groupings which
have very high density. You can see a gradient of color from left to
right in the plot; colouring by cut or clarity show different
stratifications. The combination of these very distinct statifications
results in this highly clustered embedding. It is exactly for this
reason that we need such a high <code class="docutils literal notranslate"><span class="pre">n_neighbors</span></code> value: the very local
structure of the data is merely clusters of identical categories; we
need to see wider to learn more structure.</p>
<p>Given these radically different views of the data, what do we get if we
try to integrate them together? As before we can use the intersection
and union operators to simply combine the models. As noted before this
is a somewhat time-consuming operation as a new 2D representation for
the combined models needs to be optimized.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">intersection_mapper</span> <span class="o">=</span> <span class="n">numeric_mapper</span> <span class="o">*</span> <span class="n">ordinal_mapper</span>
<span class="n">union_mapper</span> <span class="o">=</span> <span class="n">numeric_mapper</span> <span class="o">+</span> <span class="n">ordinal_mapper</span>
</pre></div>
</div>
<p>Let’s start by looking at the intersection; here we are only really
decreasing connectivity since edges are assigned the probability of
existing in <em>both</em> data views (before re-asserting local connectivity
and uniform distribution assumptions).</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">umap</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">points</span><span class="p">(</span><span class="n">intersection_mapper</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">diamonds</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;viridis&quot;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/composing_models_42_1.png" src="_images/composing_models_42_1.png" />
<p>What we get most closely represents the numeric data view. Why is this?
Because the categorical data view has points either connected with
certainty (because they are, or are nearly, identical) or very loosely.
The points connected with near certainty are very dense clusters –
almost points in the plot – and mostly what we are doing with the
intersection is breaking up those clusters with the more fine-grained
and variable connectivity provided by the numerical data. At th esame
time we have shifted the result significantly from the numerical data
view on its own; the categorical information has made each cluster more
uniform (rather than being a gradient) in its price.</p>
<p>Given this result, what would you expect of the union?</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">umap</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">points</span><span class="p">(</span><span class="n">union_mapper</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">diamonds</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">])</span>
</pre></div>
</div>
<img alt="_images/composing_models_44_1.png" src="_images/composing_models_44_1.png" />
<p>What we get in practice looks a lot more like the categorical view of
the data. This time we are only <em>increasing</em> the connectivity (prior to
re-asserting local connectivity and uniform distribution assumptions);
thus we retain most of the structure of the high-connectivity
categorical view. Note, however, that we have created more connected and
coherent clusters in the center of the plot, showing a range of diamond
colors, and the introduction of the numerical size and weight
information has induced a rearrangement of the individual clusters
around the fringes.</p>
<p>We can go a step further and experiment with the contrast composition
method.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">contrast_mapper</span> <span class="o">=</span> <span class="n">numeric_mapper</span> <span class="o">-</span> <span class="n">ordinal_mapper</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">umap</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">points</span><span class="p">(</span><span class="n">contrast_mapper</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">diamonds</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;viridis&quot;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/composing_models_47_1.png" src="_images/composing_models_47_1.png" />
<p>Here we see that we’ve retained a lot of the structure of the numeric
data view, but have refined and broken it down further into clear
clusters with price gradients running through each of them.</p>
<p>To further demonstrate the power of this approach we can go a step
further and intersect a higher <code class="docutils literal notranslate"><span class="pre">n_neighbors</span></code> based embedding of the
numeric data view with our existing union of numeric and categorical
data – providing a model that is a composition of three simpler models.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">intersect_union_mapper</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">numeric</span><span class="p">)</span> <span class="o">*</span> <span class="n">union_mapper</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">umap</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">points</span><span class="p">(</span><span class="n">intersect_union_mapper</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">diamonds</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;viridis&quot;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/composing_models_50_1.png" src="_images/composing_models_50_1.png" />
<p>Here the greater global structure from the larger <code class="docutils literal notranslate"><span class="pre">n_neighbors</span></code> value
glues together longer strands and we get an interesting result out. In
this case it is not necessarily particularly informative, but it is
included as a demonstration that even composed models can be composed
with each other, stacking together potentially many different views.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="outliers.html" class="btn btn-neutral float-left" title="Outlier detection using UMAP" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="densmap_demo.html" class="btn btn-neutral float-right" title="Better Preserving Local Density with DensMAP" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018, Leland McInnes.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>